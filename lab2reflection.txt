1. Your design probably has a type called something like Car or Vehicle that is a supertype to both Volvo and Scania. 
What is the contract for gas() and brake() in this type? Do the implementations of gas() and brake() in both Volvo 
and Scania follow this contract? Does your design follow the Liskov Substitution Principle?

    In our superclass Car our method for gas and brake work the same way as the method does in Scania but we decided to override the method to add a condition. 
    Scania can only drive if the platform is down and that is the reason we overrode it. It does not change the functionality of the method.
    We can't either gas or brake more than 1 or less than 0 due to a condition in incrementSpeed and decrementSpeed.


2. How did you handle duplicated code between Scania, the car transporters and the repair shops? Explain how you decided 
when to use subclassing and when to use composition and delegation.

    We choose to use composition. We created classes that took care of the storage and platform movements and limitations. CarTransporter and CarRepairShop uses 
    storage to keep track of its inventory. The reason we chose to use composition were because the limitations of subclassing. We needed CarTransporter to have 
    access to the methods in Car, platform and storage. Subclassing only allows for one superclass, and since we don't want all cars to have platforms or storages, 
    we use composition to share methods while not forcing all subclasses to have the same methods.


3. Did you need to modify the design from lab 1 in order to make these extensions? If so, how could you have noticed that 
your design from Lab 1 did not follow the Open-Closed Principle before you started working on Lab 2?
    
    We didn't need to change anything from lab 1 when implementing these extensions in lab 2.
